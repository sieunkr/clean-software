# 8. 단일 책임 원칙 (SRP)

## 단일 책임 원칙

응집도(cohesion)라고도 부른다. 

> 한 클래스는 단 한가자의 변경 이유만을 가져야 한다. 

2개의 책임을 별개의 클래스로 분리하는 일이 중요한 이유? 요구사항이 변경될 때, 이 변경은 클래스 안에서의 책임 변경을 통해 명백해진다. 
한 클래스가 두개 이상의 책임을 맡는다면, 그 클래스를 변경할 이유가 두 개 이상일 것이다. 

한 클래스가 두개 이상의 책임을 맡는다면, 그 책임들은 결합된다. 한 책임에 대한 변경은 다른 책임을 충족시키는 클래스의 능력을 떨어뜨리거나 저하시킬 수 있다. 
이런 종류의 결합은 변경을 했을 때 예상치 못한 방식으로 잘못 동작하는 취약한 설계를 유발한다. 

125page ~ 126page 읽어보자

## 책임이란 무엇인가?

책을 읽어보니, 무조건 분리를 해야하는지에 대한 내용인 듯..

````java
interface Modem {
    public void dial(Stringpno);
    public void hangup();
    public void send(char c);
    public char recv();
}
````

- send, recv 를 호출하는 클래스는 더 자주 재컴파일,재배포 된다면 이 설계는 좋지 않다. 분리해야 한다. 
- 반대로, 두 가지 책임의 변경이 많지 않다면 오히려 분리할 필요가 없다. 분리하면 복잡성만 높아진다. 

변경이 실제로 일어날 때 의미가 있다. 

````java
interface DataChannel {
    void send()
    char recv();
}
interface Connection {
    void dial()
    void hangup()
}
class ModemImplementation implements DataChannel, Connection {

}
````

근데, 해당 내용은 클래스를 분리한 것이 아니라, 인터페이스를 분리한 방법이다. 실제로 구현체는 하나..(?)


## 결합된 책임 분리하기

위에서 클래스는 결합된 상태로 놔뒀다. 바람직한 일은 아니지만..오히려 책임이 결합되도록 만드는 경우도 종종 있다. 
하지만 인터페이스는 분리하여 애플리케이션의 나머지 부분에 한해 개념을 분리했다. 

ModemImplementation 클래스는 이상해 보일수 있지만, 아무것도 이 클래스에 의존핮 않는다. 그래서 괜찮다는 얘기인가??
책 내용 이해 안됨... 다시 읽어봐야할 듯..


## 영속성(같은 상태가 오래 지송되는 성질?)

테스트 주도 개발 방식은 설계에서 악취가 나기 전에 두 책임을 분리하도록 만든다. 또는 퍼사드나 프록시 패턴을 사용해서 두 책임이 분리되도록 리팩토링 해야 한다.

## 결론

...



